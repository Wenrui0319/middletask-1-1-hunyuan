
引入结构化的文件归档机制

## 1. 需求背景
用户希望构建一个包含主界面和四个独立图像编辑功能的应用。核心需求如下：

- **数据共享**：通过一个共享文件夹在主界面和各编辑功能之间传递中间图像结果。
- **结构化工作流**：
    - 文件和文件夹的组织方式需要能反映工作流的内在逻辑，支持**线性操作 (1->1)** 和 **树形操作 (1->N，例如SAM)**。
    - 文件树需要实时、精确地展示这个结构。
- **工作流管理**：
    - 用户可以从文件树中**删除**不需要的文件或文件夹。
- **数据上行**：在主界面的文件树中选择图像，可以将其“上传”或发送到指定的编辑功能进行处理。
- **数据下行与自动更新**：编辑功能处理完图像并“下载”（保存）后，主界面的文件树应**通过完成信号精确触发刷新**。
- **技术栈**：项目基于 Gradio，编辑功能以内嵌 `iframe` 的形式存在。

## 2. 核心挑战与架构选型
主要挑战在于主 Gradio 应用与多个独立的、嵌入在 `iframe` 中的 Web 应用之间进行解耦、高效、有上下文的通信。
**最终选型**：一个以**共享文件系统为中心**的、**信号驱动**的、**结构化归档**的解耦架构。
- **解耦**：主应用与 `iframe` 应用不直接通信，而是通过读写共享文件夹这一“中间人”来交互。
- **信号驱动**：放弃了低效的定时轮询。UI的更新由明确的“完成信号”（一个特殊文件）触发，做到精确、实时、高效。
- **结构化归档**：文件的存放位置本身就蕴含了工作流的上下文信息，完美支持线性和树形分支。
- **轻量级**：该方案无需引入额外的消息队列或IPC机制。

## 3. 架构设计
```mermaid
graph TD
subgraph "用户浏览器"
A[主 Gradio 界面]
B[文件树 (gr.FileExplorer)]
DelBtn[删除按钮]
C[功能IFrame 1: 编辑工具A]
end
  
subgraph "服务器后端 (Python/Gradio)"
E[共享工作区 (结构化目录)]
F[信号文件监听服务]
G[主 Gradio 应用 (AIO_gradio_app.py)]
I[IFrame 应用A 后端]
end

A -- "包含" --> B
A -- "包含" --> C
A -- "包含" --> DelBtn
  
B -- "选中文件" --> DelBtn
DelBtn -- "点击" --> G
G -- "执行删除 & 刷新" --> B

F -- "1. 检测到 '信号文件'" --> G
G -- "2. 触发刷新" --> B

C -- "x. 用户完成编辑, 点击'保存'" --> I
I -- "y. 按结构化规则写入结果" --> E
I -- "z. 写入'.done'信号文件" --> E

E -- "信号文件被创建" --> F
```

## 4. 实施步骤详解

### 第一步：创建并管理共享工作区
1.  在项目根目录创建 `shared_workspace` 文件夹。
2.  修改 `AIO_gradio_app.py` 中的 `gen_save_folder` 函数，使其在 `shared_workspace` 下为每个新会话创建唯一的根目录（如 `shared_workspace/{uuid}/`）。其他功能子页面也是

### 第二步：定义并实施结构化归档规则（下载）
这是整个架构的基石。**所有 `iframe` 编辑工具在保存结果时都必须遵守**。
1.  **会话根目录**：`shared_workspace/{session_id}/`。
2.  **线性操作 (1 -> 1)**：从上传url中获取存放路径
    -   **定义**：一个输入产生一个输出。
    -   **规则**：当对 `.../working_dir/input.png` 执行线性操作时，其结果 `output.png` 必须保存在**同一目录下**：`.../working_dir/output.png`。
3.  **树形操作 (1 -> N)**：从上传url中获取存放路径
    -   **定义**：一个输入产生 N 个输出。
    -   **规则**：当对 `.../working_dir/input.png` 执行树形操作并产生 `result1.png` 和 `result2.png` 时：
        -   **创建新工作目录**：为每一个结果图像，创建一个以该图像（无扩展名）命名的**子目录**：`.../working_dir/result1/` 和 `.../working_dir/result2/`。
        -   **结果图像**保存在对应子目录：`.../working_dir/result1/result1.png` 和 `.../working_dir/result2/result2.png`。

### 第三步：实现文件树与删除功能
1.  在主应用UI中使用 `gradio.FileExplorer` 组件。
2.  在其旁边添加一个 `gr.Button("删除")`。
3.  为删除按钮编写后端函数，该函数执行 `os.remove()` 或 `shutil.rmtree()`，然后返回 `gr.update(...)` 来刷新 `FileExplorer`。

### 第四步：信号驱动的自动刷新
1.  **创建信号文件**：修改**所有 `iframe` 编辑应用**的后端。当它们完成处理并根据**第二步**的规则保存好文件后，必须在对应的目录下额外创建一个空的**信号文件**（如 `.result.png.done`）。
2.  **监听信号文件**：在主应用 `AIO_gradio_app.py` 中，创建一个轻量级的后台线程/循环，递归地检查 `shared_workspace/**/*.done` 是否存在。
3.  **触发刷新**：监听到 `.done` 文件后，立即删除该信号文件，并调用函数更新 `FileExplorer` 组件。

### 第五步：数据上行 (主界面 -> `iframe`)
此过程通过动态更新 `iframe` 的 URL 来实现。
1.  主应用后端获取被选文件的相对路径。
2.  构建新的 URL，将文件路径作为查询参数，例如：`http://.../tool-a/?file_to_edit={session_id}/cat_head.png`。
3.  `iframe` 应用的后端从 URL 解析出路径，并可以从路径中推断出当前的工作目录 (`os.path.dirname`)。
