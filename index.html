<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>工作流树</title>
    <style>
        /* 容器样式 */
        #workflow-container {
            width: 100%;
            height: 400px;
            border: 1px solid #e0e0e0;
            overflow: hidden;
            background-color: #f9f9f9;
        }

        /* SVG画布样式 */
        .workflow-svg {
            width: 100%;
            height: 100%;
        }

        /* 节点通用样式 */
        .node circle {
            stroke-width: 2px;
            cursor: pointer;
        }

        .node text {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            font-size: 14px;
            fill: white;
            text-anchor: middle;
            pointer-events: none; /* 文字不接受鼠标事件 */
        }

        /* 节点样式：蓝色背景，白色边框 */
        .node .node-background {
            fill: #3b82f6; /* 蓝色背景 */
            stroke: white; /* 白色边框 */
        }
        
        /* 选中节点的特殊样式 */
        .node.selected .node-background {
            stroke: #f59e0b; /* 醒目的橙色边框表示选中 */
            stroke-width: 4px;
        }

        /* 连线样式：白色手绘风格 */
        .link {
            fill: none;
            stroke: white;
            stroke-width: 2px;
            /* 应用SVG滤镜以实现手绘效果 */
            filter: url(#hand-drawn-filter);
        }
    </style>
</head>
<body>
    <div id="workflow-container">
        <svg class="workflow-svg">
            <!-- SVG滤镜，用于模拟手绘效果 -->
            <filter id="hand-drawn-filter" x="-50%" y="-50%" width="200%" height="200%">
                <feTurbulence baseFrequency="0.03" numOctaves="2" result="turbulence"/>
                <feDisplacementMap in="SourceGraphic" in2="turbulence" scale="3" xChannelSelector="R" yChannelSelector="G"/>
            </filter>
            <g class="workflow-links"></g>
            <g class="workflow-nodes"></g>
        </svg>
    </div>

    <!-- 引入D3.js库 -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <!-- 
      Gradio会通过某种方式将数据注入到这个window对象上，
      或者我们可以通过隐藏的组件和JS来轮询数据。
      这里我们定义一个函数，Gradio后端将通过JS调用它来传递数据。
    -->
    <script>
        // 这个全局函数将由Gradio后端调用，以传递新的树数据
        function renderWorkflowTree(treeData) {
            if (!treeData) {
                console.warn("No tree data provided to renderWorkflowTree.");
                return;
            }
            // 调用我们自定义的渲染脚本
            window.WorkflowRenderer.render(treeData);
        }

        // 这个函数用于模拟点击Gradio的隐藏按钮，将选中的节点ID传给后端
        function selectNodeInGradio(nodeId, imagePath) {
            // 1. 找到存储选中节点ID的隐藏输入框
            // Gradio通常会给组件一个CSS类，如`gradio-textbox`，并可以通过其父元素的ID来定位
            // 假设我们的隐藏输入框在ID为`#selected-node-id-input`的组件内
            const nodeIdInput = document.querySelector("#selected-node-id-input textarea");
            if (nodeIdInput) {
                nodeIdInput.value = nodeId;
                // 触发input事件，让Gradio知道值已更改
                nodeIdInput.dispatchEvent(new Event('input', { bubbles: true }));
            } else {
                console.error("Could not find the hidden node ID input for Gradio.");
            }

            // 2. 找到用于预览的隐藏按钮并点击它
            const previewButton = document.querySelector("#preview-button");
            if (previewButton) {
                // 如果需要传递额外参数（如图像路径），Gradio的JS API可能更复杂
                // 简单起见，我们假设后端仅需要nodeId
                previewButton.click();
            } else {
                console.error("Could not find the hidden preview button for Gradio.");
            }
        }
    </script>
    <!-- 引入我们自己的渲染逻辑 -->
    <script src="/file=static/js/render_tree.js"></script>
</body>
</html>